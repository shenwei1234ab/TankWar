//
//  vnPktCoder_csharp.cpp
//  vnlib
//
//  Created by Wayne on 7/24/15.
//  Copyright (c) 2015 viichi.com. All rights reserved.
//

#include "vnPacketScript.h"

#include <sstream>

using namespace _vn_ns;

#define indent str8(tab * 4, ' ')

str8 generate_csharp_type_name(const PacketScript::DataDesc &desc, bool include_array_size, const str8 &array_size = {});

str8 generate_csharp_struct_body(int tab, const std::vector<PacketScript::DataDesc> &members);

str8 generate_csharp_save_base_type(int tab, PacketScript::DataType type, const str8 &name);
str8 generate_csharp_save_type(int tab, const PacketScript::DataDesc &desc, const str8 &name);
str8 generate_csharp_load_base_type(int tab, PacketScript::DataType type, const str8 &name);
str8 generate_csharp_load_type(int tab, const PacketScript::DataDesc &desc, const str8 &name);

str8 generate_csharp(const std::vector<PacketScript::StructDesc> &structs, const std::vector<PacketScript::PacketDesc> &packets) {
    std::ostringstream oss;
    
    oss << "// generated by pktcoder." << std::endl;
    oss << "using System;" << std::endl;
    oss << "namespace pkt {" << std::endl;
    
    int tab = 1;
    
    for (auto &i : structs) {
        oss << indent << "public struct " << i.name << " {" << std::endl;
        oss << generate_csharp_struct_body(tab + 1, i.members);
        oss << indent << '}' << std::endl;
    }
    
    for (auto &i : packets) {
        oss << indent << "public class " << i.name << " : Packet {" << std::endl;
        ++tab;
        oss << indent << "public const UInt32 ID = " << i.pid << ';' << std::endl;
        oss << indent << "public UInt32 pid { get { return ID; } }" << std::endl;
        if (i.data.type != PacketScript::kDT_void) {
            oss << indent << "public " << generate_csharp_type_name(i.data, false) << " data";
            if (i.data.isArray && i.data.arraySize) {
                oss << " = new " << generate_csharp_type_name(i.data, true) << ';' << std::endl;
            } else {
                oss << ';' << std::endl;
            }
            oss << indent << "public void save(DataStream _stream) {" << std::endl;
            oss << generate_csharp_save_type(tab + 1, i.data, "data");
            oss << indent << '}' << std::endl;
            
            oss << indent << "public void load(DataStream _stream) {" << std::endl;
            ++tab;
            if (i.data.isArray && !i.data.arraySize) {
                oss << indent << "UInt32 _c = 0;" << std::endl;
            }
            oss << generate_csharp_load_type(tab, i.data, "data");
            --tab;
            oss << indent << '}' << std::endl;
        } else if (!i.members.empty()) {
            oss << indent << "public struct _Data {" << std::endl;
            oss << generate_csharp_struct_body(tab + 1, i.members);
            oss << indent << '}' << std::endl;
            oss << indent << "public _Data data;" << std::endl;
            oss << indent << "public void save(DataStream _stream) {" << std::endl;
            ++tab;
            oss << indent << "data._save(_stream);" << std::endl;
            --tab;
            oss << indent << '}' << std::endl;
            
            oss << indent << "public void load(DataStream _stream) {" << std::endl;
            ++tab;
            oss << indent << "data._load(_stream);" << std::endl;
            --tab;
            oss << indent << '}' << std::endl;
        } else {
            oss << indent << "public void save(DataStream _stream) {}" << std::endl;
            oss << indent << "public void load(DataStream _stream) {}" << std::endl;
        }
        --tab;
        oss << indent << '}' << std::endl;
    }
    
    oss << "}" << std::endl;
    
    return oss.str();
}


str8 generate_csharp_struct_body(int tab, const std::vector<PacketScript::DataDesc> &members) {
    std::ostringstream oss;
    bool has_vector = false;
    for (auto &i : members) {
        oss << indent << "public " << generate_csharp_type_name(i, false) << ' ' << i.dataName;
        if (i.isArray) {
            if (i.arraySize) {
                oss << " = new " << generate_csharp_type_name(i, true) << ';' << std::endl;
            } else {
                has_vector = true;
                oss << ';' << std::endl;
            }
        } else {
            oss << ';' << std::endl;
        }
    }
    oss << indent << "public void _save(DataStream _stream) {" << std::endl;
    ++tab;
    
    for (auto &i : members) {
        oss << generate_csharp_save_type(tab, i, i.dataName);
    }
    --tab;
    oss << indent << '}' << std::endl;
    oss << indent << "public void _load(DataStream _stream) {" << std::endl;
    ++tab;
    
    if (has_vector) {
        oss << indent << "UInt32 _c = 0;" << std::endl;
    }
    
    for (auto &i : members) {
        oss << generate_csharp_load_type(tab, i, i.dataName);
    }
    
    --tab;
    oss << indent << '}' << std::endl;
    return oss.str();
}

str8 generate_csharp_type_name(const PacketScript::DataDesc &desc, bool include_array_size, const str8 &array_size) {
    std::ostringstream oss;
    auto base_type = [&desc]() -> str8 {
        switch (desc.type) {
            case PacketScript::kDT_bool:
                return "bool";
                
            case PacketScript::kDT_u8:
                return "Byte";
                
            case PacketScript::kDT_s8:
                return "SByte";
                
            case PacketScript::kDT_u16:
                return "UInt16";
                
            case PacketScript::kDT_s16:
                return "Int16";
                
            case PacketScript::kDT_uint:
            case PacketScript::kDT_u32:
                return "UInt32";
                
            case PacketScript::kDT_int:
            case PacketScript::kDT_s32:
                return "Int32";
                
            case PacketScript::kDT_u64:
                return "UInt64";
                
            case PacketScript::kDT_s64:
                return "Int64";
                
            case PacketScript::kDT_f32:
                return "Single";
                
            case PacketScript::kDT_f64:
                return "Double";
                
            case PacketScript::kDT_string:
                return "String";
                
            case PacketScript::kDT_structure:
                return desc.typeName;
                
            default:
                break;
        }
        return {};
    };
    oss << base_type();
    if (desc.isArray) {
        if (include_array_size) {
            if (desc.arraySize) {
                oss << '[' << desc.arraySize << ']';
            } else {
                oss << '[' << array_size << ']';
            }
        } else {
            oss << '[' << ']';
        }
    }
    return oss.str();
}

str8 generate_csharp_save_base_type(int tab, PacketScript::DataType type, const str8 &name) {
    std::ostringstream oss;
    if (type == PacketScript::kDT_structure) {
        oss << indent << name << "._save(_stream);" << std::endl;
    } else if (type == PacketScript::kDT_uint) {
        oss << indent << "_stream.writeCompressedUInt(" << name << ");" << std::endl;
    } else if (type == PacketScript::kDT_int) {
        oss << indent << "_stream.writeCompressedInt(" << name << ");" << std::endl;
    } else {
        oss << indent << "_stream.write(" << name << ");" << std::endl;
    }
    return oss.str();
}

str8 generate_csharp_save_type(int tab, const PacketScript::DataDesc &desc, const str8 &name) {
    std::ostringstream oss;
    if (desc.isArray) {
        if (desc.arraySize) {
            // array
            oss << indent << "for (int _i = 0; _i < " << desc.arraySize << "; ++_i) {" << std::endl;
            oss << generate_csharp_save_base_type(tab + 1, desc.type, name + "[_i]");
            oss << '}' << std::endl;
        } else {
            // vector
            oss << indent << "if (" << name << " == null) {" << std::endl;
            ++tab;
            oss << indent << "_stream.writeCompressedUInt(0);" << std::endl;
            --tab;
            oss << indent << "} else {" << std::endl;
            ++tab;
            oss << indent << "_stream.writeCompressedUInt((UInt32)" << name << ".Length);" << std::endl;
            oss << indent << "for (long _i = 0; _i < " << name << ".Length; ++_i) {" << std::endl;
            oss << generate_csharp_save_base_type(tab + 1, desc.type, name + "[_i]");
            oss << indent << '}' << std::endl;
            --tab;
            oss << indent << '}' << std::endl;
        }
        
    } else {
        oss << generate_csharp_save_base_type(tab, desc.type, name);
    }

    return oss.str();
}

str8 generate_csharp_load_base_type(int tab, PacketScript::DataType type, const str8 &name) {
    std::ostringstream oss;
    if (type == PacketScript::kDT_structure) {
        oss << indent << name << "._load(_stream);" << std::endl;
    } else if (type == PacketScript::kDT_uint) {
        oss << indent << "_stream.readCompressedUInt(ref " << name << ");" << std::endl;
    } else if (type == PacketScript::kDT_int) {
        oss << indent << "_stream.readCompressedInt(ref " << name << ");" << std::endl;
    } else {
        oss << indent << "_stream.read(ref " << name << ");" << std::endl;
    }
    return oss.str();
}

str8 generate_csharp_load_type(int tab, const PacketScript::DataDesc &desc, const str8 &name) {
    std::ostringstream oss;
    if (desc.isArray) {
        if (desc.arraySize) {
            // array
            oss << indent << "for (int _i = 0; _i < " << desc.arraySize << "; ++_i) {" << std::endl;
            oss << generate_csharp_load_base_type(tab + 1, desc.type, name + "[_i]");
            oss << indent << '}' << std::endl;
        } else {
            // vector
            oss << indent << "_stream.readCompressedUInt(ref _c);" << std::endl;
            oss << indent << "if (_c == 0) {" << std::endl;
            ++tab;
            oss << indent << name << " = null;" << std::endl;
            --tab;
            oss << indent << "} else {" << std::endl;
            ++tab;
            oss << indent << name << " = new " << generate_csharp_type_name(desc, true, "_c") << ';' << std::endl;
            oss << indent << "for (UInt32 _i = 0; _i < _c; ++_i) {" << std::endl;
            oss << generate_csharp_load_base_type(tab + 1, desc.type, name + "[_i]");
            oss << indent << '}' << std::endl;
            --tab;
            oss << indent << '}' << std::endl;
        }
        
    } else {
        oss << generate_csharp_load_base_type(tab, desc.type, name);
    }

    return oss.str();
}